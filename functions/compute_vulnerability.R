### Function to compute vulnerability of mimetic communities from raster stack of SDM continuous outputs ###

# Based on Chazot et al., 2016 (DOI: 10.1007/978-3-319-22461-9_17)

# Compute community vulnerability as the sum of rings vulnerability approximated as the inverse of the local richness of each mimicry ring
# A ring with only one species as a vulnerability of 1/1 = 1. A ring of 4 species as a vulnerability of 1/4 = 0.25.
# Final vulnerability is standardized by total ring richness such as a community mean vulnerability

### Warning! Based on the assumption that SDM output (probability of presence/habitat suitability) are suitable proxies for species abundance, 
### thus that the number of species in a ring is a suitable proxy of the abundance of this mimicry ring in the community.


### 2 options: unweighted, and weighted with probability of presence of each ring (recommended)


### 1/ Function to compute the mean vulnerability of mimicry rings within communities

# Input = Raster Stack of species richness of mimicry rings

# Output = Raster Layer of mean vulnerability of mimicry rings within communities

compute_vulnerability <- function(ring_richness_stack)
{
  # Function to compute Vulnerability index from vector of mimicry ring abundances (or by default, proxies)
  vulnerability = function(x, na.rm) {
    x <- round(x, digits = 0) # Need to round ring richness to avoid inflation of value due to numerous rings with richness values close to 0 but not null
    if (sum(x, na.rm = T) > 0) { # Computed only if local mimicry richness >= 1 once rounded
      x <- x[x>0] # Remove all 0 values to avoid error with 1/0
      V <- sum(1/x, na.rm = T) # Compute non-standardized vulnerability = sum of mimicry ring vulnerability.
      V <- V/length(x) # Standardization by local mimicry ring richness
    }else{
      V <- NA
    }
    return(V) # Output
  }
  
  community_vulnerability <- readAll(calc(ring_richness_stack, fun = vulnerability))
  
  # Generate a mask for terrestrial areas
  continental_mask <- (readAll(calc(ring_richness_stack, fun = sum)) >= 0) - 1
  
  # Add null values as background for terrestrial areas
  vulnerability_raster <- continental_mask
  vulnerability_raster@data@values[!is.na(community_vulnerability@data@values)] <- community_vulnerability@data@values[!is.na(community_vulnerability@data@values)]
  
  # Repair issue with max value
  vulnerability_raster@data@max <- max(vulnerability_raster[], na.rm = T)
  
  return(vulnerability_raster)
}

### 2/ Function to compute the weighted mean vulnerability of mimicry rings within communities (weighted by probability of presence of each mimicry ring)

# Input = Raster Stack of species richness of mimicry rings
#         Raster Stack of probability of presence of mimicry rings

# Output = Raster Layer of weighted mean vulnerability of mimicry rings within communities


compute_weighted_vulnerability <- function(ring_richness_stack, ring_proba_stack)
{
  # Extract community data
  ring_proba_data <- getValues(ring_proba_stack)
  ring_richness_data <- round(getValues(ring_richness_stack), digits = 0) # Need to round ring richness to avoid inflation of value due to numerous rings with richness values close to 0 but not null
  
  weighted_vulnerability <- vector()
  for (i in 1:nrow(ring_richness_data))  # Loop between communities/pixels
  {
    local_ring_richness <- ring_richness_data[i,] # Extract species richness of mimicry rings for this community
    if (sum(local_ring_richness, na.rm = T) > 0) # Computed only if local mimicry richness >= 1 once rounded
    { 
      local_ring_richness_clean <- local_ring_richness[local_ring_richness > 0] # Remove all 0 values to avoid error with 1/0
      ring_vulnerability <- 1/local_ring_richness_clean # Compute non-standardized vulnerabilities = inverse of mimicry ring richness
      
      local_ring_proba <- ring_proba_data[i,] # Extract the probabilities of presence of mimicry ring in this community
      local_ring_proba_clean <- local_ring_proba[local_ring_richness > 0] # Remove all ring with richness = 0
      
      # Compute mean vulnerability weighted by probabilities of presence
      weighted_vulnerability[i] <- weighted.mean(x = ring_vulnerability, w = local_ring_proba_clean)
      
    } else { # If not enough richness, set to NA.
      weighted_vulnerability[i] <- NA
    }
  }
  
  table(weighted_vulnerability)
  
  # Generate a mask for terrestrial areas
  continental_mask <- (readAll(calc(ring_richness_stack, fun = sum)) >= 0) - 1
  
  # Add null values as background for terrestrial areas
  vulnerability_raster <- continental_mask
  vulnerability_raster@data@values[!is.na(weighted_vulnerability)] <- weighted_vulnerability[!is.na(weighted_vulnerability)]
  
  # Repair issue with max value
  vulnerability_raster@data@max <- max(vulnerability_raster[], na.rm = T)
  
  return(vulnerability_raster)
}
